name: "Build Package Workflow"
env:
  DOCKER_COMPOSE_VERSION: 1.23.0

on:
  push:
    branches:
      - main
      - release-*
      - feature/cosign-keyless-signing-release-artifacts # <---  feature branch for testing

jobs:
  BUILD_PACKAGE:
    env:
        BUILD_PACKAGE: true
    runs-on:
      - ubuntu-latest
    permissions:
      id-token: write
      contents: read
      packages: write # <-- Essential for pushing to GHCR
    steps:
      # - name: Configure AWS credentials
      #   uses: aws-actions/configure-aws-credentials@v5.0.0
      #   with:
      #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #    aws-region: us-east-1
      - name: Set up Go 1.22
        uses: actions/setup-go@v5
        with:
          go-version: 1.23.2
        id: go
      - name: Setup Docker
        uses: docker-practice/actions-setup-docker@master
        with:
          docker_version: 20.10
          docker_channel: stable
      - uses: actions/checkout@v5
      - uses: jitterbit/get-changed-files@v1
        id: changed-files
        with:
          format: space-delimited
          token: ${{ secrets.GITHUB_TOKEN }}
      - uses: actions/checkout@v5
        with:
          path: src/github.com/goharbor/harbor
      - name: Install Cosign 
        uses: sigstore/cosign-installer@v3.7.0
      - name: Build Base Image
        if: |
            contains(steps.changed-files.outputs.modified, 'Dockerfile.base') ||
            contains(steps.changed-files.outputs.modified, 'VERSION') ||
            contains(steps.changed-files.outputs.modified, '.buildbaselog') ||
            github.ref == 'refs/heads/main'
        run: |
          set -x
          echo "BUILD_BASE=true" >> $GITHUB_ENV
      - name: Build Package
        run: |
          set -x
          env
          df -h
          harbor_target_bucket=""
          target_branch="$(echo ${GITHUB_REF#refs/heads/})"
          harbor_offline_build_bundle=""
          harbor_online_build_bundle=""
          harbor_logs_bucket="harbor-ci-logs"
          harbor_builds_bucket="harbor-builds"
          harbor_releases_bucket="harbor-releases"
          harbor_ci_pipeline_store_bucket="harbor-ci-pipeline-store/latest"
          # the target release version is the version of next release(RC or GA). It needs to be updated on creating new release branch.
          target_release_version=$(cat ./VERSION | tr -d '\n\r' | sed 's/^v//') 
          Harbor_Package_Version=$target_release_version-'build.'$GITHUB_RUN_NUMBER

          if [[ $target_branch == "main" ]]; then
            Harbor_Assets_Version=$Harbor_Package_Version
            harbor_target_bucket=$harbor_builds_bucket
          else
            Harbor_Assets_Version=$target_release_version
            harbor_target_bucket=$harbor_releases_bucket/$target_branch
          fi

          if [[ $target_branch == "release-"* ]]; then
            Harbor_Build_Base_Tag=$target_release_version
          else
            Harbor_Build_Base_Tag=dev
          fi

          build_base_params=" BUILD_BASE=false"
          cd src/github.com/goharbor/harbor
          if [ -z "$BUILD_BASE"  ] || [ "$BUILD_BASE" != "true"  ]; then
            echo "Do not need to build base images!"
          else
            build_base_params=" BUILD_BASE=true PULL_BASE_FROM_DOCKERHUB=true PUSHBASEIMAGE=true REGISTRYUSER=\"${{ secrets.DOCKER_HUB_USERNAME }}\" REGISTRYPASSWORD=\"${{ secrets.DOCKER_HUB_PASSWORD }}\""
          fi
          if [ -z "$Harbor_Assets_Version" ]; then
              Harbor_Assets_Version="unknown-build-$(date +%s)" # Fallback with a unique timestamp
              echo "WARNING: Harbor_Assets_Version was empty, set to '$Harbor_Assets_Version'"
          fi
          # Ensure Harbor_Package_Version is never empty
          if [ -z "$Harbor_Package_Version" ]; then
              Harbor_Package_Version="unknown-pkg-$(date +%s)" # Fallback with a unique timestamp
              echo "WARNING: Harbor_Package_Version was empty, set to '$Harbor_Package_Version'"
          fi
          echo "DEBUG: target_release_version=$target_release_version"
          echo "DEBUG: Harbor_Package_Version=$Harbor_Package_Version"
          echo "DEBUG: Harbor_Assets_Version=$Harbor_Assets_Version"
          echo "DEBUG: Harbor_Build_Base_Tag=$Harbor_Build_Base_Tag"
          echo "DEBUG: build_base_params=$build_base_params"
          sudo make package_offline GOBUILDTAGS="include_oss include_gcs" BASEIMAGETAG=${Harbor_Build_Base_Tag} VERSIONTAG=${Harbor_Assets_Version} PKGVERSIONTAG=${Harbor_Package_Version} TRIVYFLAG=true EXPORTERFLAG=true HTTPPROXY= ${build_base_params}
          sudo make package_online GOBUILDTAGS="include_oss include_gcs" BASEIMAGETAG=${Harbor_Build_Base_Tag} VERSIONTAG=${Harbor_Assets_Version} PKGVERSIONTAG=${Harbor_Package_Version} TRIVYFLAG=true EXPORTERFLAG=true HTTPPROXY= ${build_base_params}
          harbor_offline_build_bundle=$(basename harbor-offline-installer-*.tgz)
          harbor_online_build_bundle=$(basename harbor-online-installer-*.tgz)
          echo "Package name is: $harbor_offline_build_bundle"
          echo "Package name is: $harbor_online_build_bundle"

          source tests/ci/build_util.sh
          cp ${harbor_offline_build_bundle}                 harbor-offline-installer-latest.tgz
          cp ${harbor_online_build_bundle}                  harbor-online-installer-latest.tgz
          # uploader ${harbor_offline_build_bundle}           $harbor_target_bucket
          # uploader ${harbor_online_build_bundle}            $harbor_target_bucket
          # uploader harbor-offline-installer-latest.tgz      $harbor_target_bucket
          # uploader harbor-online-installer-latest.tgz       $harbor_target_bucket
          echo "BUILD_BUNDLE=$harbor_offline_build_bundle" >> $GITHUB_ENV

        # publishImage $target_branch $Harbor_Assets_Version "${{ secrets.DOCKER_HUB_USERNAME }}" "${{ secrets.DOCKER_HUB_PASSWORD }}"
      - name: Sign Offline Installer with Cosign 
        run: |
          harbor_offline_build_bundle=$(basename harbor-offline-installer-*.tgz)
          # Use --yes to skip interactive confirmation in CI/CD
          cosign sign --yes $harbor_offline_build_bundle
        env:
          # COSIGN_REPOSITORY specifies where to store the signature metadata.
          # This typically points to an OCI registry (like ghcr.io, GCR, Docker Hub).
          # I MUST confirm the correct registry with my mentor for the main Harbor project.: What is the official OCI registry path for storing Cosign signature metadata for the goharbor/harbor project's release artifacts?
          # For a starting point, I might use ghcr.io/<your-username>/harbor for testing in your fork.
          COSIGN_REPOSITORY: ghcr.io/${{ github.repository }}

      - name: Sign Online Installer with Cosign 
        run: |
          harbor_online_build_bundle=$(basename harbor-online-installer-*.tgz)
          cosign sign --yes $harbor_online_build_bundle
        env:
          COSIGN_REPOSITORY: ghcr.io/${{ github.repository }}